### 多行语句
---
Python 通常是一行写完一条语句，但如果语句很长，我们可以使用反斜杠(\)来实现多行语句，例如：
```
total = item_one + \
        item_two + \
        item_three
在 [], {}, 或 () 中的多行语句，不需要使用反斜杠(\)，例如：

total = ['item_one', 'item_two', 'item_three',
        'item_four', 'item_five']
```
### 行与缩进

* python最具特色的就是使用缩进来表示代码块，不需要使用大括号 {} 。

* 缩进的空格数是可变的，但是同一个代码块的语句必须包含相同的缩进空格数。
---

### 字符串(String)

* python中单引号和双引号使用完全相同。
* 使用三引号('''或""")可以指定一个多行字符串。
* 转义符 '\'
* 反斜杠可以用来转义，使用r可以让反斜杠不发生转义。。 如 r"this is a line with \n" 则\n会显示，并不是换行。
* 按字面意义级联字符串，如"this " "is " "string"会被自动转换为this is string。
* 字符串可以用 + 运算符连接在一起，用 * 运算符重复。
* Python 中的字符串有两种索引方式，从左往右以 0 开始，从右往左以 -1 开始。
* Python中的字符串不能改变。
* Python 没有单独的字符类型，一个字符就是长度为 1 的字符串。
* 字符串的截取的语法格式如下：变量[头下标:尾下标]
---

### 一行显示多条语句

* Python可以在同一行中使用多条语句，语句之间使用分号(;)分割，


### 注释
* python 中多行注释使用三个单引号(''')或三个双引号(""")。

### 换行
* print 默认输出是换行的，如果要实现不换行需要在变量末尾加上 end=""：

### import 与 from...import
* 在 python 用 import 或者 from...import 来导入相应的模块。

* 将整个模块(somemodule)导入，格式为： import somemodule

* 从某个模块中导入某个函数,格式为： from somemodule import somefunction

* 从某个模块中导入多个函数,格式为： from somemodule import firstfunc, secondfunc, thirdfunc

* 将某个模块中的全部函数导入，格式为： from somemodule import *
---

### 命令行参数
python -h
---

### 多个变量赋值
* Python允许你同时为多个变量赋值。例如：
```
a = b = c = 1
```
* 您也可以为多个对象指定多个变量。例如：
```
a, b, c = 1, 2, "runoob"
```

### 标准数据类型
> Python3 中有六个标准的数据类型：

* Number（数字）
* String（字符串）
* List（列表）
* Tuple（元组）
* Set（集合）
* Dictionary（字典）
* Python3 的六个标准数据类型中：

> 不可变数据（3 个）：
* Number（数字）
* String（字符串）
* Tuple（元组）；

> 可变数据（3 个):
* List（列表）
* Dictionary（字典）
* Set（集合）
---
> 内置的 type() 函数可以用来查询变量所指的对象类型。
```
isinstance(a, int)
```
> 区别就是:

* type()不会认为子类是一种父类类型。
* isinstance()会认为子类是一种父类类型。
---

### 数值运算
* 数值的除法包含两个运算符：/ 返回一个浮点数，// 返回一个整数
---

### 字符串
* Python 使用反斜杠(\)转义特殊字符，如果你不想让反斜杠发生转义，可以在字符串前面添加一个 r，表示原始字符串
* 与 C 字符串不同的是，Python 字符串不能被改变。向一个索引位置赋值，比如word[0] = 'm'会导致错误。


### 您可以通过使用del语句删除单个或多个对象。例如：

* del var
* del var_a, var_b
---

### 注意：

1. 反斜杠可以用来转义，使用r可以让反斜杠不发生转义。
2. 字符串可以用+运算符连接在一起，用*运算符重复。
3. Python中的字符串有两种索引方式，从左往右以0开始，从右往左以-1开始。
4. Python中的字符串不能改变。
---

* 元组与字符串类似，可以被索引且下标索引从0开始，-1 为从末尾开始的位置。也可以进行截取（看上面，这里不再赘述）。

* 其实，可以把字符串看作一种特殊的元组。
---

### tuple

* 虽然tuple的元素不可改变，但它可以包含可变的对象，比如list列表。

* 构造包含 0 个或 1 个元素的元组比较特殊，所以有一些额外的语法规则：
* tup1 = ()    # 空元组
* tup2 = (20,) # 一个元素，需要在元素后添加逗号
---

### 注意
---
1. 与字符串一样，元组的元素不能修改。
2. 元组也可以被索引和切片，方法一样。
3. 注意构造包含0或1个元素的元组的特殊语法规则。
4. 元组也可以使用+操作符进行拼接。
---

### 集合
> Set（集合）
* 集合（set）是由一个或数个形态各异的大小整体组成的，构成集合的事物或对象称作元素或是成员。

* 基本功能是进行成员关系测试和删除重复元素。

* 可以使用大括号 { } 或者 set() 函数创建集合，注意：创建一个空集合必须用 set() 而不是 { }，因为 { } 是用来创建一个空字典。
---

```
# set可以进行集合运算
a = set('abracadabra')
b = set('alacazam')
 
print(a)
 
print(a - b)     # a和b的差集
 
print(a | b)     # a和b的并集
 
print(a & b)     # a和b的交集
 
print(a ^ b)     # a和b中不同时存在的元素
```

### Dictionary（字典）
* 字典（dictionary）是Python中另一个非常有用的内置数据类型。

* 列表是有序的对象集合，字典是无序的对象集合。两者之间的区别在于：字典当中的元素是通过键来存取的，而不是通过偏移存取。

* 字典是一种映射类型，字典用"{ }"标识，它是一个无序的键(key) : 值(value)对集合。

* 键(key)必须使用不可变类型。

* 在同一个字典中，键(key)必须是唯一的。
---

### 字典迭代式子
```
{x: x**2 for x in (2, 4, 6)}
{2: 4, 4: 16, 6: 36}
```
---
### 注意
> 注意：

1. 字典是一种映射类型，它的元素是键值对。
2. 字典的关键字必须为不可变类型，且不能重复。
3. 创建空字典使用 { }。
---

### Python数据类型转换
```
有时候，我们需要对数据内置的类型进行转换，数据类型的转换，你只需要将数据类型作为函数名即可。

以下几个内置的函数可以执行数据类型之间的转换。这些函数返回一个新的对象，表示转换的值。

函数	描述
int(x [,base])

将x转换为一个整数

float(x)

将x转换到一个浮点数

complex(real [,imag])

创建一个复数

str(x)

将对象 x 转换为字符串

repr(x)

将对象 x 转换为表达式字符串

eval(str)

用来计算在字符串中的有效Python表达式,并返回一个对象

tuple(s)

将序列 s 转换为一个元组

list(s)

将序列 s 转换为一个列表

set(s)

转换为可变集合

dict(d)

创建一个字典。d 必须是一个序列 (key,value)元组。

frozenset(s)

转换为不可变集合

chr(x)

将一个整数转换为一个字符

ord(x)

将一个字符转换为它的整数值

hex(x)

将一个整数转换为一个十六进制字符串

oct(x)

将一个整数转换为一个八进制字符串
---
### shell脚本方式
```

> 在Linux/Unix系统中，你可以在脚本顶部添加以下命令让Python脚本可以像SHELL脚本一样可直接执行：
```
#! /usr/bin/env python3

### 
'''
多行注释用三个单引号 ''' 或者三个双引号 """ 将注释括起来，例如:
'''
```

### 流程图

```flow
st=>start: 开始
op=>operation: My Operation
cond=>condition: Yes or No?
e=>end
st->op->cond
cond(yes)->e
cond(no)->op
&
```

---

| 运算符   |描述 | 实例|
|:----:|:------------------:|:-------------:|
| & | 按位与运算符：参与运算的两个值,如果两个相应位都为1,则该位的结果为1,否则为0 | (a & b) 输出结果 12 ，二进制解释： 0000 1100|
| | | 按位或运算符：只要对应的二个二进位有一个为1时，结果位就为1。 | (a | b) 输出结果 61 ，二进制解释： 0011 1101 |
| ^ | 按位异或运算符：当两对应的二进位相异时，结果为1 | (a ^ b) 输出结果 49 ，二进制解释： 0011 0001 |
| ~ | 按位取反运算符：对数据的每个二进制位取反,即把1变为0,把0变为1。~x 类似于 -x-1	(~a ) | 输出结果 -61 ，二进制解释： 1100 0011 在一个有符号二进制数的补码形式。 |
| << | 左移动运算符：运算数的各二进位全部左移若干位，由"<<"右边的数指定移动的位数，高位丢弃，低位补0。 | a << 2 输出结果 240 ，二进制解释： 1111 0000|
| >> | 右移动运算符：把">>"左边的运算数的各二进位全部右移若干位，">>"右边的数指定移动的位数 | a >> 2 输出结果 15 ，二进制解释： 0000 1111 |

---

```
 id() 函数用于获取对象内存地址。
```

> is 与 == 区别：

* is 用于判断两个变量引用对象是否为同一个， == 用于判断引用变量的值是否相等。
---

```
random.sample(sequence,length) 可以从指定的序列中，随机的截取指定长度的片断，不修改原序列。
```

### 随机数函数

---

|函数|描述|
|:------:|:----------:|
|choice(seq)|	从序列的元素中随机挑选一个元素，比如random.choice(range(10))，从0到9中随机挑选一个整数。|
| randrange ([start,] stop [,step])	| 从指定范围内，按指定基数递增的集合中获取一个随机数，基数缺省值为1 |
| random() |	随机生成下一个实数，它在[0,1)范围内。|
| seed([x])|	改变随机数生成器的种子seed。如果你不了解其原理，你不必特别去设定seed，Python会帮你选择seed。|
| shuffle(lst)|	将序列的所有元素随机排序|
| uniform(x, y)|	随机生成下一个实数，它在[x,y]范围内。|
| uniform(x, y) | dfdfdfd |

---

### 字符串
* 原始字符串 - 原始字符串：所有的字符串都是直接按照字面的意思来使用，没有转义特殊或不能打印的字符。 原始字符串除在字符串的第一个引号前加上字母 r（可以大小写）以外，与普通字符串有着几乎完全相同的语法。
* 在Python3中，所有的字符串都是Unicode字符串。
* 使用的语法是在字符串前面加上前缀 u
* 前面加上u/U 表示bytes
---



### Python 的字符串内建函数
> Python 的字符串常用内建函数如下：

---

|序号 | 方法及描述|
|:----:|:----------------------------------------------------------------:|
|1     | capitalize()   将字符串的第一个字符转换为大写|
|2	   |  center(width, fillchar)  返回一个指定的宽度 width 居中的字符串，fillchar 为填充的字符，默认为空格。|
| 3	 |  count(str, beg= 0,end=len(string))  返回 str 在 string 里面出现的次数，如果 beg 或者 end 指定则返回指定范围内 str 出现的次数|
| 4	 |   bytes.decode(encoding="utf-8", errors="strict") | Python3 中没有 decode 方法，但我们可以使用 bytes 对象的 decode() 方法来解码给定的 bytes 对象，这个 bytes 对象可以由 str.encode() 来编码返回。|
| 5 |	encode(encoding='UTF-8',errors='strict')   以 encoding 指定的编码格式编码字符串，如果出错默认报一个ValueError 的异常，除非 errors 指定的是'ignore'或者'replace' |
|  6 |  endswith(suffix, beg=0, end=len(string))  检查字符串是否以 obj 结束，如果beg 或者 end 指定则检查指定的范围内是否以 obj 结束，如果是，返回 True,否则返回 False. |
| 7 |	expandtabs(tabsize=8)  把字符串 string 中的 tab 符号转为空格，tab 符号默认的空格数是 8 。|
|8  |	find(str, beg=0 end=len(string))  检测 str 是否包含在字符串中，如果指定范围 beg 和 end ，则检查是否包含在指定范围内，如果包含返回开始的索引值，否则返回-1 |
| 9	|  index(str, beg=0, end=len(string))  跟find()方法一样，只不过如果str不在字符串中会报一个异常.|
| 10 |	isalnum()  如果字符串至少有一个字符并且所有字符都是字母或数字则返 回 True,否则返回 False |
|11 |	isalpha()  如果字符串至少有一个字符并且所有字符都是字母则返回 True, 否则返回 False |
| 12  |	 isdigit()   如果字符串只包含数字则返回 True 否则返回 False.. |
| 13  |	 islower()   如果字符串中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是小写，则返回 True，否则返回 False |
| 14  | isnumeric()    如果字符串中只包含数字字符，则返回 True，否则返回 False |
| 15 |  isspace()   如果字符串中只包含空白，则返回 True，否则返回 False. |
| 16 |  istitle()  如果字符串是标题化的(见 title())则返回 True，否则返回 False  |
| 17 |  isupper()  如果字符串中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是大写，则返回 True，否则返回 False |
| 18 |  join(seq)  以指定字符串作为分隔符，将 seq 中所有的元素(的字符串表示)合并为一个新的字符串 | 
| 19 |  len(string)  返回字符串长度 |
| 20 |	ljust(width[, fillchar])  返回一个原字符串左对齐,并使用 fillchar 填充至长度 width 的新字符串，fillchar 默认为空格。|
| 21 |  lower()  转换字符串中所有大写字符为小写. |
| 22 |	lstrip()  截掉字符串左边的空格或指定字符。 |
| 23 |	 maketrans()  创建字符映射的转换表，对于接受两个参数的最简单的调用方式，第一个参数是字符串，表示需要转换的字符，第二个参数也是字符串表示转换的目标。|
|24 |	max(str)   返回字符串 str 中最大的字母。 |
| 25 | min(str)  返回字符串 str 中最小的字母。  |
| 26 |  replace(old, new [, max])  把 将字符串中的 str1 替换成 str2,如果 max 指定，则替换不超过 max 次。 |
| 27 |	 rfind(str, beg=0,end=len(string))   类似于 find()函数，不过是从右边开始查找. |
| 28 |  rindex( str, beg=0, end=len(string))  类似于 index()，不过是从右边开始. |
| 29 | rjust(width,[, fillchar])  返回一个原字符串右对齐,并使用fillchar(默认空格）填充至长度 width 的新字符串 |
| 30 | rstrip()  删除字符串字符串末尾的空格. |
| 31 | split(str="", num=string.count(str))  num=string.count(str)) 以 str 为分隔符截取字符串，如果 num 有指定值，则仅截取 num 个子字符串 |
|32 | 	splitlines([keepends])  按照行('\r', '\r\n', \n')分隔，返回一个包含各行作为元素的列表，如果参数 keepends 为 False，不包含换行符，如果为 True，则保留换行符。 |
| 33 |  startswith(str, beg=0,end=len(string))  检查字符串是否是以 obj 开头，是则返回 True，否则返回 False。如果beg 和 end 指定值，则在指定范围内检查。|
| 34 | 	strip([chars])  在字符串上执行 lstrip()和 rstrip() |
|35  |	swapcase()  将字符串中大写转换为小写，小写转换为大写  |
| 36 |  title()  返回"标题化"的字符串,就是说所有单词都是以大写开始，其余字母均为小写(见 istitle()) |
| 37 | 	translate(table, deletechars="")  根据 str 给出的表(包含 256 个字符)转换 string 的字符, 要过滤掉的字符放到 deletechars 参数中 |
|38  | 	upper()  转换字符串中的小写字母为大写 |
| 39 | 	zfill (width) 返回长度为 width 的字符串，原字符串右对齐，前面填充0|
| 40 |  isdecimal()  检查字符串是否只包含十进制字符，如果是返回 true，否则返回 false。 |

---

### 列表list

```
序列是Python中最基本的数据结构。序列中的每个元素都分配一个数字 - 它的位置，或索引，第一个索引是0，第二个索引是1，依此类推。

Python有6个序列的内置类型，但最常见的是列表和元组。

序列都可以进行的操作包括索引，切片，加，乘，检查成员。

此外，Python已经内置确定序列的长度以及确定最大和最小的元素的方法。

列表是最常用的Python数据类型，它可以作为一个方括号内的逗号分隔值出现。

列表的数据项不需要具有相同的类型

创建一个列表，只要把逗号分隔的不同的数据项使用方括号括起来即可。
```

---
* list.append()
* del list[0]
---

### Python列表脚本操作符
> do
* 列表对 + 和 * 的操作符与字符串相似。+ 号用于组合列表，* 号用于重复列表。

---

|Python 表达式| 	结果	 |描述      |
|:--------:|:-------:|:-------:|
|len([1, 2, 3]) |	3|	长度|
|[1, 2, 3] + [4, 5, 6] |  [1, 2, 3, 4, 5, 6]	|组合|
|['Hi!'] * 4 |	['Hi!', 'Hi!', 'Hi!', 'Hi!'] |	重复|
|3 in [1, 2, 3]|	True	|元素是否存在于列表中 |
|for x in [1, 2, 3]: print(x, end=" ") |	1 2 3 |	迭代|

---


### Python列表函数&方法
> Python包含以下函数:

|序号	|函数 |
|:---:|:--------:|
|1	|len(list) 列表元素个数 |
|2	| max(list)  返回列表元素最大值|
|3	|min(list) 返回列表元素最小值 |
|4	|list(seq)  将元组转换为列表|

> Python包含以下方法:

|序号	|方法|
|:-----:|:----------------:|
|1|	list.append(obj) 在列表末尾添加新的对象|
|2|	list.count(obj)   统计某个元素在列表中出现的次数|
|3|	list.extend(seq)   在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）|
|4|	list.index(obj)   从列表中找出某个值第一个匹配项的索引位置|
|5|	list.insert(index, obj)   将对象插入列表 |
|6|	list.pop([index=-1])  移除列表中的一个元素（默认最后一个元素），并且返回该元素的值|
|7|	list.remove(obj)   移除列表中某个值的第一个匹配项|
|8 | list.reverse()   反向列表中元素 |
| 9|	list.sort(cmp=None, key=None, reverse=False)    对原列表进行排序 |
|10|	list.clear()   清空列表  |
|11|	list.copy()  复制列表| 
---


### 元组
---

* tup = "a", "b", "c", "d" 不加括号也可以表示tuple
* 创建空元组 tup1 = ()
* 元组中只包含一个元素时，需要在元素后面添加逗号，否则括号会被当作运算符使用
* 元组中的元素值是不允许修改的，但我们可以对元组进行连接组合
* 元组中的元素值是不允许删除的，但我们可以使用del语句来删除整个元组
---

### 元组运算符
> 与字符串一样，元组之间可以使用 + 号和 * 号进行运算。这就意味着他们可以组合和复制，运算后会生成一个新的元组。

|Python 表达式	|结果	|描述|
|:---------:|:---------:|:---:|
|len((1, 2, 3)) | 3| 计算元素个数|
|(1, 2, 3) + (4, 5, 6)|	(1, 2, 3, 4, 5, 6)	|连接|
|('Hi!',) * 4|	('Hi!', 'Hi!', 'Hi!', 'Hi!')|	复制|
|3 in (1, 2, 3)	|True	|元素是否存在|
|for x in (1, 2, 3): print (x,)|	1 2 3	|迭代|

---

### 字典
---
> 两个重要的点需要记住：

* 不允许同一个键出现两次。创建时如果同一个键被赋值两次，后一个值会被记住，如下实例
* 键必须不可变，所以可以用数字，字符串或元组充当，而用列表就不行
* str(dict) 输出字典，以可打印的字符串表示。

### Python字典包含了以下内置方法：

|序号	|函数及描述|
|:----:|:------------:|
|1|	radiansdict.clear() 删除字典内所有元素|
|2	|radiansdict.copy()  返回一个字典的浅复制|
|3	|radiansdict.fromkeys() 创建一个新字典，以序列seq中元素做字典的键，val为字典所有键对应的初始值 |
|4	|radiansdict.get(key, default=None) 返回指定键的值，如果值不在字典中返回default值 |
|5	|key in dict 如果键在字典dict里返回true，否则返回false|
|6	| radiansdict.items()  以列表返回可遍历的(键, 值) 元组数组|
|7	| radiansdict.keys() 返回一个迭代器，可以使用 list() 来转换为列表|
|8	| radiansdict.setdefault(key, default=None) 和get()类似, 但如果键不存在于字典中，将会添加键并将值设为default|
|9	| radiansdict.update(dict2)  把字典dict2的键/值对更新到dict里|
|10 |	radiansdict.values()  返回一个迭代器，可以使用 list() 来转换为列表| 
|11	| pop(key[,default])  删除字典给定键 key 所对应的值，返回值为被删除的值。key值必须给出。 否则，返回default值。|
|12	| popitem() 随机返回并删除字典中的一对键和值(一般删除末尾对). |

### Python3 集合
* 集合（set）是一个无序的不重复元素序列。
* 可以使用大括号 { } 或者 set() 函数创建集合，注意：创建一个空集合必须用 set() 而不是 { }，因为 { } 是用来创建一个空字典。
* s.add( x )
* s.update( x )
* s.remove( x )
* s.discard( x )
* s.pop()  我们也可以设置随机删除集合中的一个元素，语法格式如下
* len(s)
* s.clear()
* x in s


### 集合内置方法完整列表

|方法	|描述|
|:------:|:-------------------:|
|add()	|为集合添加元素   |
|clear()	|移除集合中的所有元素|
|copy()	|  拷贝一个集合|
| difference()	|  返回多个集合的差集|
| difference_update()	|  移除集合中的元素，该元素在指定的集合也存在。|
| discard()	  | 删除集合中指定的元素 |
| intersection()	| 返回集合的交集 |
| intersection_update()	 | 删除集合中的元素，该元素在指定的集合中不存在。|
| isdisjoint()	| 判断两个集合是否包含相同的元素，如果没有返回 True，否则返回 False。|
| issubset()	| 判断指定集合是否为该方法参数集合的子集。 |
| issuperset()	|  判断该方法的参数集合是否为指定集合的子集  |
| pop()	  |   随机移除元素  |
| remove()	 |      移除指定元素  |
| symmetric_difference()	| 返回两个集合中不重复的元素集合。   |
|  symmetric_difference_update()	|  移除当前集合中在另外一个指定集合相同的元素，并将另外一个指定集合中不同的元素插入到当前集合中。 |
| union()	|  返回两个集合的并集    |
| update()	|   给集合添加元素     |
---


### end 关键字
> 关键字end可以用于将结果输出到同一行，或者在输出的末尾添加不同的字符，实例如下：
```
#!/usr/bin/python3
 
# Fibonacci series: 斐波纳契数列
# 两个元素的总和确定了下一个数
a, b = 0, 1
while b < 1000:
    print(b, end=',')
    a, b = b, a+b

```

### if
* Python 中用 elif 代替了 else if，所以if语句的关键字为：if – elif – else。
---

* 类似if语句的语法，如果你的while循环体中只有一条语句，你可以将该语句与while写在同一行中， 如下所示：
```
#!/usr/bin/python
 
flag = 1
 
while (flag): print ('欢迎访问菜鸟教程!')
 
print ("Good bye!")
```
* 循环语句可以有 else 子句，它在穷尽列表(以for循环)或条件变为 false (以while循环)导致循环终止时被执行,但循环被break终止时不执行。
---

### pass 语句
* Python pass是空语句，是为了保持程序结构的完整性。
* pass 不做任何事情，一般用做占位语句


### 迭代器
* 迭代是Python最强大的功能之一，是访问集合元素的一种方式。
* 迭代器是一个可以记住遍历的位置的对象。
* 迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。
* 迭代器有两个基本的方法：iter() 和 next()
* 字符串，列表或元组对象都可用于创建迭代器
* 迭代器对象可以使用常规for语句进行遍历
---

### 创建一个迭代器
```
把一个类作为一个迭代器使用需要在类中实现两个方法 __iter__() 与 __next__() 。

如果你已经了解的面向对象编程，就知道类都有一个构造函数，Python 的构造函数为 __init__(), 它会在对象初始化的时候执行。更多内容查阅：Python3 面向对象

__iter__() 方法返回一个特殊的迭代器对象， 这个迭代器对象实现了 __next__() 方法并通过 StopIteration 异常标识迭代的完成。

__next__() 方法（Python 2 里是 next()）会返回下一个迭代器对象。

创建一个返回数字的迭代器，初始值为 1，逐步递增
```

# StopIteration
> StopIteration 异常用于标识迭代的完成，防止出现无限循环的情况，在 __next__() 方法中我们可以设置在完成指定循环次数后触发 StopIteration 异常来结束迭代。
```
class MyNumbers:
  def __iter__(self):
    self.a = 1
    return self
 
  def __next__(self):
    if self.a <= 20:
      x = self.a
      self.a += 1
      return x
    else:
      raise StopIteration
 
myclass = MyNumbers()
myiter = iter(myclass)
 
for x in myiter:
  print(x)
```

### 生成器
* 在 Python 中，使用了 yield 的函数被称为生成器（generator）。

* 跟普通函数不同的是，生成器是一个返回迭代器的函数，只能用于迭代操作，更简单点理解生成器就是一个迭代器。

* 在调用生成器运行的过程中，每次遇到 yield 时函数会暂停并保存当前所有的运行信息，返回 yield 的值, 并在下一次执行 next() 方法时从当前位置继续运行。

* 调用一个生成器函数，返回的是一个迭代器对象。
---

### 判断是否是generator
```
>>>from inspect import isgeneratorfunction 
>>> isgeneratorfunction(fab) 
True
```

```
>>>import types 
>>> isinstance(fab, types.GeneratorType) 
False 
>>> isinstance(fab(5), types.GeneratorType) 
True
```

```
def read_file(fpath): 
    BLOCK_SIZE = 1024 
    with open(fpath, 'rb') as f: 
        while True: 
            block = f.read(BLOCK_SIZE) 
            if block: 
                yield block 
            else: 
                return
```

### Python3 函数
* 函数是组织好的，可重复使用的，用来实现单一，或相关联功能的代码段。

* 函数能提高应用的模块性，和代码的重复利用率。你已经知道Python提供了许多内建函数，比如print()。但你也可以自己创建函数，这被叫做用户自定义函数。

* 定义一个函数
* 你可以定义一个由自己想要功能的函数，以下是简单的规则：

* 函数代码块以 def 关键词开头，后接函数标识符名称和圆括号 ()。
* 任何传入参数和自变量必须放在圆括号中间，圆括号之间可以用于定义参数。
* 函数的第一行语句可以选择性地使用文档字符串—用于存放函数说明。
* 函数内容以冒号起始，并且缩进。
* return [表达式] 结束函数，选择性地返回一个值给调用方。不带表达式的return相当于返回 None。

---
### 语法
* Python 定义函数使用 def 关键字，一般格式如下：
```
def 函数名（参数列表）:
    函数体
```

### 参数
> 以下是调用函数时可使用的正式参数类型：

* 必需参数
* 关键字参数
* 默认参数
* 不定长参数


### 必需参数
> 必需参数须以正确的顺序传入函数。调用时的数量必须和声明时的一样。
> 调用printme()函数，你必须传入一个参数，不然会出现语法错误：
```
实例(Python 3.0+)
#!/usr/bin/python3
 
#可写函数说明
def printme( str ):
   "打印任何传入的字符串"
   print (str)
   return
 
#调用printme函数
printme()
```

### 关键字参数
> 关键字参数和函数调用关系紧密，函数调用使用关键字参数来确定传入的参数值。

* 使用关键字参数允许函数调用时参数的顺序与声明时不一致，因为 Python 解释器能够用参数名匹配参数值。

---
### 默认参数
* 调用函数时，如果没有传递参数，则会使用默认参数。以下实例中如果没有传入 age 参数

### 不定长参数
* 你可能需要一个函数能处理比当初声明时更多的参数。这些参数叫做不定长参数，和上述 2 种参数不同，声明时不会命名。

---


### 加了星号 * 的参数会以元组(tuple)的形式导入，存放所有未命名的变量参数。
---
实例(Python 3.0+)
#!/usr/bin/python3
  
# 可写函数说明
```
def printinfo( arg1, *vartuple ):
   "打印任何传入的参数"
   print ("输出: ")
   print (arg1)
   print (vartuple)
 
# 调用printinfo 函数
printinfo( 70, 60, 50 )
```

### 还有一种就是参数带两个星号 **基本语法如下：
* 加了两个星号 ** 的参数会以字典的形式导入。
```
如果单独出现星号 * 后的参数必须用关键字传入。
>>> def f(a,b,*,c):
...     return a+b+c
... 
>>> f(1,2,3)   # 报错
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: f() takes 2 positional arguments but 3 were given
>>> f(1,2,c=3) # 正常
6
>>>
```
### 匿名函数
> python 使用 lambda 来创建匿名函数。
* 所谓匿名，意即不再使用 def 语句这样标准的形式定义一个函数。
* lambda 只是一个表达式，函数体比 def 简单很多。
* lambda的主体是一个表达式，而不是一个代码块。仅仅能在lambda表达式中封装有限的逻辑进去。
* lambda 函数拥有自己的命名空间，且不能访问自己参数列表之外或全局命名空间里的参数。
* 虽然lambda函数看起来只能写一行，却不等同于C或C++的内联函数，后者的目的是调用小函数时不占用栈内存从而增加运行效率。
### 语法
* lambda 函数的语法只包含一个语句，如下：
* lambda [arg1 [,arg2,.....argn]]:expression
---
### 变量作用域
> Python 中，程序的变量并不是在哪个位置都可以访问的，访问权限决定于这个变量是在哪里赋值的。
* 变量的作用域决定了在哪一部分程序可以访问哪个特定的变量名称。Python的作用域一共有4种，分别是：
```
L （Local） 局部作用域
E （Enclosing） 闭包函数外的函数中
G （Global） 全局作用域
B （Built-in） 内建作用域
以 L –> E –> G –>B 的规则查找，即：在局部找不到，便会去局部外的局部找（例如闭包），再找不到就会去全局找，再者去内建中找。

```
### global 和 nonlocal关键字
当内部作用域想修改外部作用域的变量时，就要用到global和nonlocal关键字了。
```
以下实例修改全局变量 num：

实例(Python 3.0+)
#!/usr/bin/python3
 
num = 1
def fun1():
    global num  # 需要使用 global 关键字声明
    print(num) 
    num = 123
    print(num)
fun1()
print(num)
```
### 如果要修改嵌套作用域（enclosing 作用域，外层非全局作用域）中的变量则需要 nonlocal 关键字了，如下实例：
> 实例(Python 3.0+)
```
#!/usr/bin/python3
 
def outer():
    num = 10
    def inner():
        nonlocal num   # nonlocal关键字声明
        num = 100
        print(num)
    inner()
    print(num)
outer()
```
### 如果要修改嵌套作用域（enclosing 作用域，外层非全局作用域）中的变量则需要 nonlocal 关键字了，如下实例：
> 实例(Python 3.0+)
```
#!/usr/bin/python3

def outer():
    num = 10
    def inner():
        nonlocal num   # nonlocal关键字声明
        num = 100
        print(num)
    inner()
    print(num)
outer()
```
### Python数据结构
|方法|	描述|
|:------:|:---------:|
|list.append(x)	|把一个元素添加到列表的结尾，相当于 a[len(a):] = [x]。|
|list.extend(L)	| 通过添加指定列表的所有元素来扩充列表，相当于 a[len(a):] = L。|
|list.insert(i, x)	| 在指定位置插入一个元素。第一个参数是准备插入到其前面的那个元素的索引，例如 a.insert(0, x) 会插入到整个列表之前，而 a.insert(len(a), x) 相当于 a.append(x) |
|list.remove(x)	| 删除列表中值为 x 的第一个元素。如果没有这样的元素，就会返回一个错误。|
|list.pop([i])	| 从列表的指定位置移除元素，并将其返回。如果没有指定索引，a.pop()返回最后一个元素。元素随即从列表中被移除。（方法中 i 两边的方括号表示这个参数是可选的，而不是要求你输入一对方括号，你会经常在 Python 库参考手册中遇到这样的标记。）|
|list.clear()	| 移除列表中的所有项，等于del a[:]。|
|list.index(x)	| 返回列表中第一个值为 x 的元素的索引。如果没有匹配的元素就会返回一个错误。|
|list.count(x)	|   返回 x 在列表中出现的次数。|
|list.sort()	| 对列表中的元素进行排序。|
| list.reverse()	| 倒排列表中的元素。|
|list.copy()	|返回列表的浅复制，等于a[:]。 |
---
> 下面示例演示了列表的大部分方法：
```
>>> a = [66.25, 333, 333, 1, 1234.5]
>>> print(a.count(333), a.count(66.25), a.count('x'))
2 1 0
>>> a.insert(2, -1)
>>> a.append(333)
>>> a
[66.25, 333, -1, 333, 1, 1234.5, 333]
>>> a.index(333)
1
>>> a.remove(333)
>>> a
[66.25, -1, 333, 1, 1234.5, 333]
>>> a.reverse()
>>> a
[333, 1234.5, 1, 333, -1, 66.25]
>>> a.sort()
>>> a
[-1, 1, 66.25, 333, 333, 1234.5]

```
* 注意：类似 insert, remove 或 sort 等修改列表的方法没有返回值。
---
### 将列表当做堆栈使用
* 列表方法使得列表可以很方便的作为一个堆栈来使用，堆栈作为特定的数据结构，最先进入的元素最后一个被释放（后进先出）。用 append() 方法可以把一个元素添加到堆栈顶。用不指定索引的 pop() 方法可以把一个元素从堆栈顶释放出来
### 将列表当作队列使用
* 也可以把列表当做队列用，只是在队列里第一加入的元素，第一个取出来；但是拿列表用作这样的目的效率不高。在列表的最后添加或者弹出元素速度快，然而在列表里插入或者从头部弹出速度却不快（因为所有其他的元素都得一个一个地移动）。
### Python3模块
* 模块是一个包含所有你定义的函数和变量的文件，其后缀名是.py。模块可以被别的程序引入，以使用该模块中的函数等功能。这也是使用 python 标准库的方法。
* 一个模块只会被导入一次，不管你执行了多少次import。这样可以防止导入模块被一遍又一遍地执行。
* 当我们使用import语句的时候，Python解释器是怎样找到对应的文件的呢？
* 这就涉及到Python的搜索路径，搜索路径是由一系列目录名组成的，Python解释器就依次从这些目录中去寻找所引入的模块。
* 这看起来很像环境变量，事实上，也可以通过定义环境变量的方式来确定搜索路径。
* 搜索路径是在Python编译或安装的时候确定的，安装新的库应该也会修改。搜索路径被存储在sys模块中的path变量，做一个简单的实验，在交互式解释器中
---
### sys.path
* sys.path 输出是一个列表，其中第一项是空串''，代表当前目录（若是从一个脚本中打印出来的话，可以更清楚地看出是哪个目录），亦即我们执行python解释器的目录（对于脚本的话就是运行的脚本所在的目录）。
* 因此若像我一样在当前目录下存在与要引入模块同名的文件，就会把要引入的模块屏蔽掉。
* 了解了搜索路径的概念，就可以在脚本中修改sys.path来引入一些不在搜索路径中的模块。
---

### from … import 语句
* Python 的 from 语句让你从模块中导入一个指定的部分到当前命名空间中，语法如下：

### from … import * 语句
> 把一个模块的所有内容全都导入到当前的命名空间也是可行的，只需使用如下声明：

* from modname import *
---

### 深入模块
* 模块除了方法定义，还可以包括可执行的代码。这些代码一般用来初始化这个模块。这些代码只有在第一次被导入时才会被执行。

* 每个模块有各自独立的符号表，在模块内部为所有的函数当作全局符号表来使用。

* 所以，模块的作者可以放心大胆的在模块内部使用这些全局变量，而不用担心把其他用户的全局变量搞花。

* 从另一个方面，当你确实知道你在做什么的话，你也可以通过 modname.itemname 这样的表示法来访问模块内的函数。

* 模块是可以导入其他模块的。在一个模块（或者脚本，或者其他地方）的最前面使用 import 来导入一个模块，当然这只是一个惯例，而不是强制的。被导入的模块的名称将被放入当前操作的模块的符号表中。

* 还有一种导入的方法，可以使用 import 直接把模块内（函数，变量的）名称导入到当前操作模块。比如:
```
>>> from fibo import fib, fib2
>>> fib(500)
1 1 2 3 5 8 13 21 34 55 89 144 233 377
```
* 这种导入的方法不会把被导入的模块的名称放在当前的字符表中（所以在这个例子里面，fibo 这个名称是没有定义的）。

* 这还有一种方法，可以一次性的把模块中的所有（函数，变量）名称都导入到当前模块的字符表:
```
>>> from fibo import *
>>> fib(500)
1 1 2 3 5 8 13 21 34 55 89 144 233 377
```
* 这将把所有的名字都导入进来，但是那些由单一下划线（_）开头的名字不在此例。大多数情况，Python程序员不使用这种方法，因为引入的其它来源的命名，很可能覆盖了已有的定义。
---


### 如果没有给定参数，那么 dir() 函数会罗列出当前定义的所有名称:
```
>>> a = [1, 2, 3, 4, 5]
>>> import fibo
>>> fib = fibo.fib
>>> dir() # 得到一个当前模块中定义的属性列表
['__builtins__', '__name__', 'a', 'fib', 'fibo', 'sys']
>>> a = 5 # 建立一个新的变量 'a'
>>> dir()
['__builtins__', '__doc__', '__name__', 'a', 'sys']
>>>
>>> del a # 删除变量名a
>>>
>>> dir()
['__builtins__', '__doc__', '__name__', 'sys']
>>>
```

### 标准模块
> Python 本身带着一些标准的模块库，在 Python 库参考文档中将会介绍到（就是后面的"库参考文档"）。

* 有些模块直接被构建在解析器里，这些虽然不是一些语言内置的功能，但是他却能很高效的使用，甚至是系统级调用也没问题。

* 这些组件会根据不同的操作系统进行不同形式的配置，比如 winreg 这个模块就只会提供给 Windows 系统。

* 应该注意到这有一个特别的模块 sys ，它内置在每一个 Python 解析器中。变量 sys.ps1 和 sys.ps2 定义了主提示符和副提示符所对应的字符串:
```
>>> import sys
>>> sys.ps1
'>>> '
>>> sys.ps2
'... '
>>> sys.ps1 = 'C> '
C> print('Yuck!')
Yuck!
C>
```


### 包
* 包是一种管理 Python 模块命名空间的形式，采用"点模块名称"。

* 比如一个模块的名称是 A.B， 那么他表示一个包 A中的子模块 B 。

* 就好像使用模块的时候，你不用担心不同模块之间的全局变量相互影响一样，采用点模块名称这种形式也不用担心不同库之间的模块重名的情况。

* 这样不同的作者都可以提供 NumPy 模块，或者是 Python 图形库。

* 不妨假设你想设计一套统一处理声音文件和数据的模块（或者称之为一个"包"）。

* 现存很多种不同的音频文件格式（基本上都是通过后缀名区分的，例如： .wav，:file:.aiff，:file:.au，），所以你需要有一组不断增加的模块，用来在不同的格式之间转换。

* 并且针对这些音频数据，还有很多不同的操作（比如混音，添加回声，增加均衡器功能，创建人造立体声效果），所以你还需要一组怎么也写不完的模块来处理这些操作。

* 这里给出了一种可能的包结构（在分层的文件系统中）:
```
sound/                          顶层包
      __init__.py               初始化 sound 包
      formats/                  文件格式转换子包
              __init__.py
              wavread.py
              wavwrite.py
              aiffread.py
              aiffwrite.py
              auread.py
              auwrite.py
              ...
      effects/                  声音效果子包
              __init__.py
              echo.py
              surround.py
              reverse.py
              ...
      filters/                  filters 子包
              __init__.py
              equalizer.py
              vocoder.py
              karaoke.py
              ...
```

* 在导入一个包的时候，Python 会根据 sys.path 中的目录来寻找这个包中包含的子目录。

* 目录只有包含一个叫做 __init__.py 的文件才会被认作是一个包，主要是为了避免一些滥俗的名字（比如叫做 string）不小心的影响搜索路径中的有效模块。

* 最简单的情况，放一个空的 :file:__init__.py就可以了。当然这个文件中也可以包含一些初始化代码或者为（将在后面介绍的） __all__变量赋值。

* 用户可以每次只导入一个包里面的特定模块，比如:
```
import sound.effects.echo
这将会导入子模块:sound.effects.echo。 他必须使用全名去访问:

sound.effects.echo.echofilter(input, output, delay=0.7, atten=4)
还有一种导入子模块的方法是:

from sound.effects import echo
这同样会导入子模块: echo，并且他不需要那些冗长的前缀，所以他可以这样使用:

echo.echofilter(input, output, delay=0.7, atten=4)
还有一种变化就是直接导入一个函数或者变量:

from sound.effects.echo import echofilter
同样的，这种方法会导入子模块: echo，并且可以直接使用他的 echofilter() 函数:

echofilter(input, output, delay=0.7, atten=4)

注意当使用from package import item这种形式的时候，对应的item既可以是包里面的子模块（子包），或者包里面定义的其他名称，比如函数，类或者变量。

import语法会首先把item当作一个包定义的名称，如果没找到，再试图按照一个模块去导入。如果还没找到，恭喜，一个:exc:ImportError 异常被抛出了。

反之，如果使用形如import item.subitem.subsubitem这种导入形式，除了最后一项，都必须是包，而最后一项则可以是模块或者是包，但是不可以是类，函数或者变量的名字。

从一个包中导入*
设想一下，如果我们使用 from sound.effects import *会发生什么？

Python 会进入文件系统，找到这个包里面所有的子模块，一个一个的把它们都导入进来。

但是很不幸，这个方法在 Windows平台上工作的就不是非常好，因为Windows是一个大小写不区分的系统。

在这类平台上，没有人敢担保一个叫做 ECHO.py 的文件导入为模块 echo 还是 Echo 甚至 ECHO。

（例如，Windows 95就很讨厌的把每一个文件的首字母大写显示）而且 DOS 的 8+3 命名规则对长模块名称的处理会把问题搞得更纠结。

为了解决这个问题，只能烦劳包作者提供一个精确的包的索引了。

导入语句遵循如下规则：如果包定义文件 __init__.py 存在一个叫做 __all__ 的列表变量，那么在使用 from package import * 的时候就把这个列表中的所有名字作为包内容导入。

作为包的作者，可别忘了在更新包之后保证 __all__ 也更新了啊。你说我就不这么做，我就不使用导入*这种用法，好吧，没问题，谁让你是老板呢。这里有一个例子，在:file:sounds/effects/__init__.py中包含如下代码:

__all__ = ["echo", "surround", "reverse"]
这表示当你使用from sound.effects import *这种用法时，你只会导入包里面这三个子模块。

如果 __all__ 真的没有定义，那么使用from sound.effects import *这种语法的时候，就不会导入包 sound.effects 里的任何子模块。他只是把包sound.effects和它里面定义的所有内容导入进来（可能运行__init__.py里定义的初始化代码）。

这会把 __init__.py 里面定义的所有名字导入进来。并且他不会破坏掉我们在这句话之前导入的所有明确指定的模块。看下这部分代码:

import sound.effects.echo
import sound.effects.surround
from sound.effects import *
这个例子中，在执行from...import前，包sound.effects中的echo和surround模块都被导入到当前的命名空间中了。（当然如果定义了__all__就更没问题了）

通常我们并不主张使用*这种方法来导入模块，因为这种方法经常会导致代码的可读性降低。不过这样倒的确是可以省去不少敲键的功夫，而且一些模块都设计成了只能通过特定的方法导入。

记住，使用from Package import specific_submodule这种方法永远不会有错。事实上，这也是推荐的方法。除非是你要导入的子模块有可能和其他包的子模块重名。

如果在结构中包是一个子包（比如这个例子中对于包sound来说），而你又想导入兄弟包（同级别的包）你就得使用导入绝对的路径来导入。比如，如果模块sound.filters.vocoder 要使用包sound.effects中的模块echo，你就要写成 from sound.effects import echo。

from . import echo
from .. import formats
from ..filters import equalizer
无论是隐式的还是显式的相对导入都是从当前模块开始的。主模块的名字永远是"__main__"，一个Python应用程序的主模块，应当总是使用绝对路径引用。

包还提供一个额外的属性__path__。这是一个目录列表，里面每一个包含的目录都有为这个包服务的__init__.py，你得在其他__init__.py被执行前定义哦。可以修改这个变量，用来影响包含在包里面的模块和子包。

这个功能并不常用，一般用来扩展包里面的模块。

```

---
### 输出格式美化
* Python两种输出值的方式: 表达式语句和 print() 函数。

* 第三种方式是使用文件对象的 write() 方法，标准输出文件可以用 sys.stdout 引用。

* 如果你希望输出的形式更加多样，可以使用 str.format() 函数来格式化输出值。

* 如果你希望将输出的值转成字符串，可以使用 repr() 或 str() 函数来实现。

* str()： 函数返回一个用户易读的表达形式。
* repr()： 产生一个解释器易读的表达形式。
---

* 字符串对象的 rjust() 方法, 它可以将字符串靠右, 并在左边填充空格。

* 还有类似的方法, 如 ljust() 和 center()。 这些方法并不会写任何东西, 它们仅仅返回新的字符串。

* 另一个方法 zfill(), 它会在数字的左边填充 0

> str.format() 的基本使用如下:
```
>>> print('{}网址： "{}!"'.format('菜鸟教程', 'www.runoob.com'))
菜鸟教程网址： "www.runoob.com!"
```
* 括号及其里面的字符 (称作格式化字段) 将会被 format() 中的参数替换。

* 在括号中的数字用于指向传入对象在 format() 中的位置，如下所示：
```
>>> print('{0} 和 {1}'.format('Google', 'Runoob'))
Google 和 Runoob
>>> print('{1} 和 {0}'.format('Google', 'Runoob'))
Runoob 和 Google
如果在 format() 中使用了关键字参数, 那么它们的值会指向使用该名字的参数。

>>> print('{name}网址： {site}'.format(name='菜鸟教程', site='www.runoob.com'))
菜鸟教程网址： www.runoob.com
位置及关键字参数可以任意的结合:

>>> print('站点列表 {0}, {1}, 和 {other}。'.format('Google', 'Runoob',
                                                       other='Taobao'))
站点列表 Google, Runoob, 和 Taobao。
'!a' (使用 ascii()), '!s' (使用 str()) 和 '!r' (使用 repr()) 可以用于在格式化某个值之前对其进行转化:

>>> import math
>>> print('常量 PI 的值近似为： {}。'.format(math.pi))
常量 PI 的值近似为： 3.141592653589793。
>>> print('常量 PI 的值近似为： {!r}。'.format(math.pi))
常量 PI 的值近似为： 3.141592653589793。
```


> 可选项 ':' 和格式标识符可以跟着字段名。 这就允许对值进行更好的格式化。 下面的例子将 Pi 保留到小数点后三位：
```
>>> import math
>>> print('常量 PI 的值近似为 {0:.3f}。'.format(math.pi))
```
* 常量 PI 的值近似为 3.142。
> 在 ':' 后传入一个整数, 可以保证该域至少有这么多的宽度。 用于美化表格时很有用。
```
>>> table = {'Google': 1, 'Runoob': 2, 'Taobao': 3}
>>> for name, number in table.items():
...     print('{0:10} ==> {1:10d}'.format(name, number))
...
Runoob     ==>          2
Taobao     ==>          3
Google     ==>          1
如果你有一个很长的格式化字符串, 而你不想将它们分开, 那么在格式化时通过变量名而非位置会是很好的事情。

最简单的就是传入一个字典, 然后使用方括号 '[]' 来访问键值 :

>>> table = {'Google': 1, 'Runoob': 2, 'Taobao': 3}
>>> print('Runoob: {0[Runoob]:d}; Google: {0[Google]:d}; Taobao: {0[Taobao]:d}'.format(table))
Runoob: 2; Google: 1; Taobao: 3
```

> 也可以通过在 table 变量前使用 '**' 来实现相同的功能：
```
>>> table = {'Google': 1, 'Runoob': 2, 'Taobao': 3}
>>> print('Runoob: {Runoob:d}; Google: {Google:d}; Taobao: {Taobao:d}'.format(**table))
Runoob: 2; Google: 1; Taobao: 3
旧式字符串格式化
% 操作符也可以实现字符串格式化。 它将左边的参数作为类似 sprintf() 式的格式化字符串, 而将右边的代入, 然后返回格式化后的字符串. 例如:

>>> import math
>>> print('常量 PI 的值近似为：%5.3f。' % math.pi)
常量 PI 的值近似为：3.142。
因为 str.format() 比较新的函数， 大多数的 Python 代码仍然使用 % 操作符。但是因为这种旧式的格式化最终会从该语言中移除, 应该更多的使用 str.format().
```

### 读取键盘输入
> Python提供了 input() 内置函数从标准输入读入一行文本，默认的标准输入是键盘。
```
input 可以接收一个Python表达式作为输入，并将运算结果返回。

#!/usr/bin/python3

str = input("请输入：");
print ("你输入的内容是: ", str)
这会产生如下的对应着输入的结果：

请输入：菜鸟教程
你输入的内容是:  菜鸟教程
```

### 读和写文件
* open() 将会返回一个 file 对象，基本语法格式如下:
```
open(filename, mode)
filename：包含了你要访问的文件名称的字符串值。
mode：决定了打开文件的模式：只读，写入，追加等。所有可取值见如下的完全列表。这个参数是非强制的，默认文件访问模式为只读(r)。
不同模式打开文件的完全列表
```
---

|模式	|描述   |
|:------:|:------:|
|r	| 以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。|
|rb	| 以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。|
|r+	| 打开一个文件用于读写。文件指针将会放在文件的开头。|
|rb+ |	以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。|
|w	| 打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。|
|wb | 以二进制格式打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。|
|w+	 | 打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。| 
|wb+	| 以二进制格式打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。|
|a	| 打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。|
|ab |	以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。|
|a+	|打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。|
|ab+ | 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。|
---


### pickle 模块
* python的pickle模块实现了基本的数据序列和反序列化。

* 通过pickle模块的序列化操作我们能够将程序中运行的对象信息保存到文件中去，永久存储。

* 通过pickle模块的反序列化操作，我们能够从文件中创建上一次程序保存的对象。

### 基本接口：

* pickle.dump(obj, file, [,protocol])
* 有了 pickle 这个对象, 就能对 file 以读取的形式打开:
* x = pickle.load(file)
* 注解：从 file 中读取一个字符串，并将它重构为原来的python对象。
* file: 类文件对象，有read()和readline()接口。

> 实例1：
```
#!/usr/bin/python3
import pickle

# 使用pickle模块将数据对象保存到文件
data1 = {'a': [1, 2.0, 3, 4+6j],
         'b': ('string', u'Unicode string'),
         'c': None}

selfref_list = [1, 2, 3]
selfref_list.append(selfref_list)

output = open('data.pkl', 'wb')

# Pickle dictionary using protocol 0.
pickle.dump(data1, output)

# Pickle the list using the highest protocol available.
pickle.dump(selfref_list, output, -1)

output.close()
实例2：

#!/usr/bin/python3
import pprint, pickle

#使用pickle模块从文件中重构python对象
pkl_file = open('data.pkl', 'rb')

data1 = pickle.load(pkl_file)
pprint.pprint(data1)

data2 = pickle.load(pkl_file)
pprint.pprint(data2)

pkl_file.close()
```


